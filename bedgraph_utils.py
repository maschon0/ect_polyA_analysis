import multiprocessing as mp
import numpy as np
import time

def parse_bedgraph(filepath, strand):
    """ Reads a file in the bedgraph format
    and stores each value in a nested dictionary """
    
    if strand not in ['+','-','.']:
        print("ERROR: strand must be + - or .")
        return
    
    coverage_dict = {}
    coverage_dict['+'] = {}
    coverage_dict['-'] = {}
    coverage_dict['.'] = {}
    
    coverage_file = open(filepath)
    
    for line in coverage_file:
        if line[0] == '#':
            continue
        l = line.rstrip().split()
        chrom = l[0]
        start = int(l[1])
        end = int(l[2])
        value = float(l[3])
        
        if value == 0:
            continue
        
        if chrom not in coverage_dict[strand]:
            coverage_dict[strand][chrom] = {}
        
        for pos in range(start, end):
            coverage_dict[strand][chrom][pos] = \
                coverage_dict[strand][chrom].get(pos,float(0)) + value
    
    coverage_file.close()
    return coverage_dict


def add_bedgraph(coverage_dict, filepath, strand):
    """ Adds a new bedgraph file to an existing
    coverage_dict generated by parse_bedgraph """
    
    coverage_file = open(filepath)
    
    for line in coverage_file:
        if line[0] == '#':
            continue
        l = line.rstrip().split()
        chrom = l[0]
        start = int(l[1])
        end = int(l[2])
        value = float(l[3])
        
        if value == 0:
            continue
        
        for pos in range(start, end):
            coverage_dict[strand][chrom][start:end] += value
    
    coverage_file.close()
    

def parse_multi_bedgraph(filepath, strand, multi_key):
    """ Reads a file in the multi-column bedgraph format
    and stores each value in a nested dictionary """
    
    if strand not in ['+','-','.']:
        print("ERROR: strand must be + - or .")
        return
    
    coverage_dict = {}
    coverage_dict['+'] = {}
    coverage_dict['-'] = {}
    coverage_dict['.'] = {}
    
    coverage_file = open(filepath)
    
    for line in input_file:
        if line[0] == '#':
            continue
        l = line.rstrip().split()
        chrom = l[0]
        start = int(l[1])
        end = int(l[2])
        countvals = [float(i) for i in l[3:]]
        
        if chrom not in coverage_dict[strand]:
            coverage_dict[strand][chrom] = {}
        
        for pos in range(start, end):
            for i in range(len(multikey)):
                if countvals[i] > 0:
                    if pos not in coverage_dict[s][chrom]:
                        coverage_dict[s][chrom][pos] = {}
                    coverage_dict[s][chrom][pos][multikey[i]] = UNTEMP[s][chrom][pos].get(multikey[i],0) + countvals[i]
    
    input_file.close()
    return coverage_dict    


def add_multi_bedgraph(coverage_dict, filepath, strand, multi_key):
    """ Adds a new bedgraph file to an existing
    coverage_dict generated by parse_multi_bedgraph """
    
    coverage_file = open(filepath)
    
    for line in coverage_file:
        if line[0] == '#':
            continue
        l = line.rstrip().split()
        chrom = l[0]
        start = int(l[1])
        end = int(l[2])
        countvals = [float(i) for i in l[3:]]
        
        if chrom not in coverage_dict[strand]:
            coverage_dict[strand][chrom] = {}
        
        for pos in range(start, end):
            for i in range(len(multikey)):
                if countvals[i] > 0:
                    if pos not in coverage_dict[s][chrom]:
                        coverage_dict[s][chrom][pos] = {}
                    coverage_dict[s][chrom][pos][multikey[i]] = UNTEMP[s][chrom][pos].get(multikey[i],0) + countvals[i]
    
    coverage_file.close()

def write_bedgraph_from_dict(input, output_filename, digits=2, parallel=False, multi_key=False):
    """Writes BEDGRAPH to output_filename from input dict"""
    
    def writer(merge_filename,shared_queue,stop_token):
        """Initializes a writer to output the mp queue."""
        dest_file = open(merge_filename,'w')
        while True:
            line = shared_queue.get()
            if line == stop_token:
                dest_file.close()
                return
            dest_file.write(line)
    
    
    def generate_bedgraph_lines(values_dict, chrom, queue, digits=digits, parallel=parallel, multi_key=multi_key):
        """Converts dict of values to bedgraph format"""
        start = 0
        prevpos = 0
        prevcount = None
        chromlen = len(input[chrom])
        position = None
        # Iterate through every position with values in the dict
        for position in sorted(list(values_dict.keys())):
            if multi_key:
                all_values = [str(round(values_dict[position].get(k,0),digits)) for k in multi_key]
                count = '\t'.join(all_values)
            else:
                count = round(values_dict[position],digits)
            
            if count != prevcount or int(position) > 1 + prevpos:
                # The newly encountered value is not a continuation
                # of the previous value. Write the old run and start another.
                if prevcount and prevcount != 0:
                    line_to_write = '\t'.join(
                        [
                            str(i) for i in [
                                chrom,
                                start,
                                prevpos + 1,
                                prevcount
                            ]
                        ]
                    ) + '\n'
                    
                    if parallel:
                        # Write the old run to outfile
                        queue.put(line_to_write)
                    else:
                        # Write the old run to outfile
                        queue.write(line_to_write)
                        
                start = position
            prevcount = count
            prevpos = int(position)
        
        if position and prevcount and prevcount != 0:
            line_to_write = '\t'.join(
                [
                    str(i) for i in [
                        chrom,
                        start,
                        prevpos + 1,
                        prevcount
                    ]
                ]
            ) + '\n'
            
            if parallel:
                queue.put(line_to_write)
            else:
                queue.write(line_to_write)
    
    
    if parallel:
        queue = mp.Queue()
        STOP_TOKEN = "FINISHED"
        writer_process = mp.Process(
            target=writer,
            args=(output_filename,queue,STOP_TOKEN)
        )
        writer_process.start()
        
        if multi_key:
            first_line = '#chrom\tstart\tend\t{}\n'.format(
                '\t'.join([str(i) for i in multi_key])
            )
            queue.put(first_line)
        
        all_threads = []
        
        for chrom in sorted(list(input.keys())):
            all_threads.append(
                mp.Process(
                    target=generate_bedgraph_lines,
                    args=(
                        input[chrom],
                        chrom,
                        queue
                    )
                )
            )
        for i in range(len(all_threads)):
            all_threads[i].start()
        while len(mp.active_children()) > 1:
            time.sleep(1)
        queue.put("FINISHED")
        while len(mp.active_children()) > 0:
            time.sleep(1)
    else:
        queue = open(output_filename, 'w')
        if multi_key:
            first_line = '#chrom\tstart\tend\t{}\n'.format(
                '\t'.join([str(i) for i in multi_key])
            )
            queue.write(first_line)
        
        for chrom in sorted(list(input.keys())):
            generate_bedgraph_lines(
                input[chrom],
                chrom,
                queue,
                parallel = False
            )
        queue.close()